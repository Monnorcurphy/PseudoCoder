<head>
  <title>PseudoCoder</title>
  <link rel="icon" type="image/png" href="http://res.cloudinary.com/dqiuefax1/image/upload/v1490361371/dd4248443aa6d679087376ec9749bcae_brain-clip-art-at-vector-clip-brain-animated-clipart_600-455_ub4afn.png">
  <meta charset="utf-8" />
  <link href="https://fonts.googleapis.com/css?family=Rajdhani:400,600,700" rel="stylesheet">
  <link rel="stylesheet" type="text/css" href=".././assets/css/reset.css">
  <link rel="stylesheet" type="text/css" href=".././assets/css/searching.css">
  <link rel="stylesheet" type="text/css" href=".././assets/css/navigation.css">

</head>
<body>
<div>
  <div class = 'main'>
    <div class='table-of-contents'>
      <nav id="contents">
        <ul class="links">

          <div class="support">
          <li class="Chapter white">
            <a href="../index.html" class='bright main-button'>Main</a>
          </li>
            <li class="Chapter white"><a href="../about.html" class='bright main-button'>About</a></li>
          </div>
          <li class="Chapter yellow">
            <a href="../ch1/efficiency.html" class='bright'>Ch 1: Efficiency</a>
          </li>

          <li class="Chapter green"><a href="../ch2/data_structures.html">Ch 2: Data Structures </a></li>

          <li class="Chapter blue"><a href="searching-sorting.html" class='bright'>Ch 3: Searching/sorting</a></li>

          <li class="Chapter blue subset">
            <a href="terminology.html" class='bright'>3.1 Terminology</a>
          </li>

          <li class="Chapter blue subset">
            <a href="simple-search.html" class='bright'>3.2 Simple Search</a>
          </li>
          <li class="Chapter blue subset">
            <a href="bfs-dfs.html" class='bright'>3.3 Graph Search</a>
          </li>

          <li class="Chapter blue subset">
            <a href="simple-sort.html" class='bright'>3.4 Simple Sorts</a>
          </li>
          <li class="Chapter blue subset">
            <a href="hard-sort.html" class='bright'>3.5 Hard Sorts</a>
          </li>
          <li class="Chapter blue subset">
            <a href="summary.html" class='bright'>3.6 Summary</a>
          </li>

          <li class="Chapter red"><a href="../ch4/object-oriented.html">Ch 4: Object Oriented</a></li>

          <li class="Chapter orange"><a href="../ch5/architechture.html" class='bright'>Ch 5: Architechture</a></li>

          <li class="Chapter purple"><a href="">Glossary</a></li>

        </ul>
      </nav>
    </div>
  <div class= 'right-text'>
    <h2>Graph Search</h2>
  <h4>BFS</h4>
  <p>
    Now let’s say that you really hated the name Carmen, because that is
    something that you would do. That’s what people think of you. And
    you are the type of person to take this next level. Not only do you
    not want friends named Carmen, but you don’t want to be friends with
    anyone who knows anyone named Carmen. There are two ways to handle
    that situation.
  </p>
  <p>First, you could go through all of your friends, asking their names,
    and if anyone is named Carmen, you cut them out (don’t kill them, as
    this is highly illegal and your defense would be flimsy at best).
    Next, you go through your friend's friends, cutting out friends who
    have friends named Carmen. But your craziness doesn’t stop there,
    you have to check your friend's friend's friends, since if they know a
    Carmen, then through the transitive property your friend knows a
    Carmen, and then you know a Carmen. Dear GOD!
  </p>

  <p>
    That is called Breadth First Search. I will show you an example, but
    it is going to take the most imagination of all. We have to pretend
    you have friends.
  </p>

  <p>
    You—> Bill, Lolita, Jimmy  
    <br>
    <br>
    They are all clean so you go through their friends.
    <br>
    You —> Bill, Lolita, Jimmy —> Bill’s friends(Caleb, Sophie, Ben)…etc.
    <br>
    <br>
    You add each person’s friends after searching them. By contrast you
    could search each friend individually, then their friends, then their
    friend's friends.
  </p>
  <p>
    You —> Bill —> Caleb —> no friends
    <br>
    You —> Bill —> Sophie —> Jimmy —>… Too many to imagine
    <br>
    You—> Bill —> Ben —> Dr. Urchin —>…who cares, you get it.
  </p>
  <h4>DFS</h4>
  <p>
    In Depth First Search, instead of searching your friends,
    then your friends friends, then your friends friends friends, etc.
    you search each friend’s connections first. Rooting out the Carmen’s
    one friend at a time. The better depends on which way will lead to
    a Carmen the fastest.
  </p>

  <p>A more straightforward example would be if you live in the city
    and you are looking for a peach farmer. Are you going to search your
    friends, and then their friends? No way! A peach farmer is more
    likely to be a friend of a friend’s friend. So you should pick the
    person who is most likely to have a peach farmer in their network.
    Like Jimmy, he knows everyone. That would be Depth First Search.
  </p>
  <p> But if you are a farmer and you are looking for a peach farmer,
    your direct friends are more likely to have those connections, so
    you might use Breadth First Search instead, but that depends on the
    farmer.
  </p>
    <p>
    The Big O notation is tricky for this one. So we have to make sure
    we are not visiting nodes twice, since in that case this could take
    an infinite time period.
  </p>
    <p>
      Big O would be O(N) where N is the number of nodes.
     </p>

  <h4>Comparing BFS and DFS</h4>
  <p>
    If you think about this, one of those searches is actually slightly
    more optimal than the other. Did you figure it out? I am
    <i class='Italics'>sure</i> you did. In an unbalanced tree, there is
    little difference, but there is an interesting edge case to think
    about. Let's assume a balanced tree. That means the depth of the tree
    is lg n, and the tree has similar or equal left and right sub-trees.
    If you do DFS, at most you will go lg n elements deep, storing lg n
    in recursive stack calls. In BFS, you will not do that, in the worst
    case you will store half of all of the nodes on a graph.
  </p>
  <p>
    Think of the way BFS works. You search all children of a node, then
    you search each of the children's children. So, imagine yourself
    on the second to last level of a tree. At this point, you will add
    each of their children. If the tree is balanced, than as you go
    farther down, the more children each node has. Meaning data is
    concentrated towards the bottom, and on the final level, you have
    half of all the data in the tree. So, when you BFS the final level
    of a tree, you are storing half of the entire tree in memory. Ouch.
  </p>

  <h4>Practice</h4>
  <h5 class ='document'><a href='23Q.html' target= '_blank'>Ch 3.3 Questions</a></h5>
  <h5 class ='document'><a href="../assets/Answers/2.3 Answers.zip" download>Ch 3.3 Answers</a></h5>


    <h4>Sources/Further Reading</h4>
    <ul>
      <li> <a class= 'Sources' href="https://en.wikipedia.org/wiki/Breadth-first_search" target="_blank">Wikipedia - BFS</a></li>
      <li> <a class= 'Sources' href="https://en.wikipedia.org/wiki/Depth-first_search" target="_blank">Wikipedia - DFS</a></li>
      <li> <a class= 'Sources' href="http://ask.metafilter.com/7921/If-you-killed-somebody-how-would-you-dispose-of-the-body-without-getting-caught" target="_blank">Not Suspicious</a></li>

    </ul>

  </div>
</div>
</body>
