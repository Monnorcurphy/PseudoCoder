<head>
  <title>Algorithm's</title>
  <meta charset="utf-8" />
  <link rel="stylesheet" type="text/css" href=".././assets/css/reset.css">
  <link rel="stylesheet" type="text/css" href=".././assets/css/sorting.css">
  <link rel="stylesheet" type="text/css" href=".././assets/css/navigation.css">
  <link href="https://fonts.googleapis.com/css?family=Rajdhani:400,600,700" rel="stylesheet">

</head>
<body>
<div>
  <div class = 'main'>
    <div class='table-of-contents'>
      <nav id="contents">
        <ul class="links">

          <div class="support">
          <li class="Chapter white">
            <a href="../index.html" class='bright main-button'>Main</a>
          </li>
            <li class="Chapter white"><a href="../about.html" class='bright main-button'>About</a></li>
          </div>
          <li class="Chapter yellow">
            <a href="../ch1/efficiency.html" class='bright'>Ch 1: Efficiency</a>
          </li>

          <li class="Chapter green"><a href="../ch2/data_structures.html">Ch 2: Data Structures </a></li>

          <li class="Chapter blue"><a href="../ch3/searching.html" class='bright'>Ch 3: Searching</a></li>

          <li class="Chapter red"><a href="sorting.html">Ch 4: Sorting</a></li>
            <li class="Chapter red subset">
            <a href="terminology.html">1.1 Terminology</a>
            </li>
            <li class="Chapter red subset">
            <a href="basic.html">1.2 Basic Sorts</a>
            </li>
            <li class="Chapter red subset">
            <a href="advanced.html">1.3 Advanced Sorts</a>
            </li>
          <li class="Chapter red subset">
            <a href="summary.html">1.4 Summary</a>
            </li>

          <li class="Chapter orange"><a href="../ch5/architechture.html" class='bright'>Ch 5: Architechture</a></li>

          <li class="Chapter purple"><a href="">Glossary</a></li>

        </ul>
      </nav>
    </div>
  <div class= 'right-text'>
    <h2>Tricky Sorting</h2>
    <h4>Dijikstra's</h4>
      <p>Let’s talk about maps. We could choose a lot of companies like….Apple.

      Alright, enough jokes. Google does maps, and unlike some they are quite good at it. How do they solve the issue of determining the shortest path from one place to another? Or the shortest time?  So, what you do is calculate the distance to each point individually. Each point that you have yet to reach is infinity distance away. When you reach a new node, you replace the existing value, if the value you calculated to reach it is shorter. Here is how it would work.

      Let’s say you started at point A, and you needed to get to point New York, because that punk Chris owes you money.  You could go from:
      A to B to New York
      or
      A to  C to B to New York.

      Here is how you would calculate. First, one step. From A to B or A to C. If the distance from A to B is 10, and the distance from A to C is 5, then you put in those values. Shortest distance from A to B goes from infinity, to 10, and from A to C goes to 5. Now, the next step. From B to NY is 48. From C to B is 3. 
      The shortest distance to NY is set to 58, the shortest distance to B goes to 8. Now, the last step goes from B to NY, which goes from 58 to 56.  This is Dijikstra’s algorithm. There are different variants of it. Some forms only calculate the distance between two points. The one I just explained assumed A was the source, and then calculates the distance to every node. Updating as it goes along.</p>

    <h4>Heap sort</h4>
      <p>*Stop* If you don’t know what a heap is, go to the data structures page.*Continue*

      A brief refresher (since I am sure NO ONE will not know what a heap is, but everyone likes a nice reminder). Heaps are semi-sorted piles of numbers. The are either max heaps (biggest values on top) or min heaps (smaller values on top). There is not guarantee of sorting, so just because you have 100 at the top of a heap, doesn’t mean 99, 98, or any numbers above 10 are in the heap. It just means 100, is on top, and is the largest value (max heap).  Again, because it matters, overtime you add a value to a heap, you have to adjust the heap until it is in the right spot. That, is what we are about to talk about.

      Since heaps are always numbers, there isn’t really a analogous way to talk about them. In a max heap, the highest value is on top, the two values below this value (the children nodes) are lower than the top value, and are greater than their children, and so on. This means, that as you go further down, you are going to find lower values. So, what if you want to add a value to a max heap? Easy, you add the value to to the top, pushing the current top value to down to the right or left.

      Now, you sort the heap, which looks like this. You compare the top value to it’s two children. If it is larger, you are done. If not, you pick the greater of the two children, put it on top. You then compare the new spot where the node is, against its two new children. You continue to do this, swapping the values, until everything is in the proper place.

      Min heaps work the same way, just with minimum values. You can also add values to the bottom, and reverse it.  Now, how long does this process take. Well in Big O, n log n. But so it’s its Big Theta. Which makes it not the best n log n sorting algorithm. It is also not stable. For more about that, check out these resources.</p>

    <h4>Radix</h4>
      <p>Radix sort is the idea that you can sort numbers, by just looking at parts of the number, or whatever you are sorting, rather than the whole thing at once. There are two types of radix sort, each of which are better for different things.

      LSD- Least significant digit, not the drug one. This is typically more useful for numbers. You start at the end of every thing you are sorting, putting them in order. Like so:

      	   compare                  compare                  compare
      941 —> 1    THEN	941 —> 4  THEN	941 —> 9
      573 —> 3   		573—> 7  		573—> 5
      465—> 5			465 —> 6		465 —> 4

      This is advantageous when you are comparing numbers of different sizes (1, 435, etc.) There is another way to do Radix, MSD or most significant digit.

      Most significant digit is actually typically used for words, since radix sort sorts everything by value, and then lexicographically. What that means is this:

      a —> ab —> abc —>b

      This is because b is greater in value than nothing, and c is greater in value than nothing. But, because of the beginning letter (a), they still come before b. You don’t want to sort numbers lexicographically though, since it would end up like this:

      1 —> 10 —> 2</p>
    <h4>A* (A Star, just like you aren't)</h4>
    <p>Similar to Dijikstra’s, we could image that we must compute the lowest distance between two nodes. But instead of traveling through all the nodes, we take guesses at how to best reach our destination.  We must know our staring position, and our ending position, which we do, A —> New York. Now, we calculate the distance between our points, and the points distance from New York. And try to take the best path based on that.  You can see the assumptions this makes, we have to know which way is closer to NY, but can you see the issues. What if the next spot is closer, but there are obstructions which inhibit the travel from the closer point.

    Let’s say from A to B or A to C, B is closer to New York, but you have to drive around some mountains, making the overall distance longer. A star is efficient at calculating the lowest distance between two points, but it requires some knowledge (distance between nodes) and has some dangerous assumptions.</p>

  </div>
</div>
</body>
