<head>


  <title>PseudoCoder</title>
  <link rel="icon" type="image/png" href="http://res.cloudinary.com/dqiuefax1/image/upload/v1490361371/dd4248443aa6d679087376ec9749bcae_brain-clip-art-at-vector-clip-brain-animated-clipart_600-455_ub4afn.png">
  <meta charset="utf-8" />
  <link rel="stylesheet" type="text/css" href=".././assets/css/reset.css">
  <link rel="stylesheet" type="text/css" href=".././assets/css/architechture.css">
  <link rel="stylesheet" type="text/css" href=".././assets/css/navigation.css">

</head>
<body>
<div>
  <div class = 'main'>
    <div class='table-of-contents'>
			<nav id="contents">
				<ul class="links">

          <div class="support">
          <li class="Chapter white">
            <a href="../index.html" class='bright main-button'>Main</a>
          </li>
            <li class="Chapter white"><a href="../about.html" class='bright main-button'>About</a></li>
          </div>
					<li class="Chapter yellow">
						<a href="../ch1/efficiency.html" class='bright'>Ch 1: Efficiency</a>
					</li>

					<li class="Chapter green"><a href="../ch2/data_structures.html">Ch 2: Data Structures </a></li>

          <li class="Chapter blue"><a href="../ch3/searching-sorting.html">Ch 3: Searching/sorting</a></li>
          <li class="Chapter red"><a href="ch4/object-oriented.html">Ch 4: Object Oriented</a></li>

	        <li class="Chapter orange"><a href="architechture.html" class='bright'>Ch 5: Architechture</a></li>

              <li class="Chapter orange subset">
                <a href="terminology.html" class='bright'>5.1 Terminology</a>
              </li>
              <li class="Chapter orange subset">
                <a href="internet.html" class='bright'>5.2 The Internet</a>
              </li>
              <li class="Chapter orange subset">
                <a href="first-half.html" class='bright'>5.3 Distributed Systems</a>
              </li>
              <li class="Chapter orange subset">
                <a href="second-half.html" class='bright'>5.4 ohter stuff</a>
              </li>
              <li class="Chapter orange subset">
                <a href="summary.html" class='bright'>5.5 Summary</a>
              </li>

	        <li class="Chapter purple"><a href="">Glossary</a></li>

	  	    </ul>
			</nav>
		</div>
  <div class= 'right-text'>

  <h2>Array- A Single File Line</h2>
  <h4>Terms</h4>
  <p>What is a Process? How do multitasking, threads work?

  A process is a computer program that is being executed. Depending on OS, a process can have multiple threads of execution, some of which are executed concurrently.

  Multitasking allows process to share processors (CPUs) and other resources. Each CPU executes a task, but multitasking allows processes to share processors. When a processor is handling multiple processes, it is switching.

  Switches happen when tasks preform input/output operations*, a task indicates it can be switched, or hardware interrupts*.

  Input/output (I/O)- the communication between an information processing system (i.e.- computer) and the outside world (a human, or other processing system). Input- signals or data received by the system, output are the signals or data sent out.  Input devices - keyboard, mouse
  Output devices- Monitors, printers

  Hardware interrupts- a signal to the processor indicating an event needs immediate attention. The processor responds by saving state and executing an interrupt handler. interrupts can be either hardware or software interrupts.

  Hardware interrupts- Can be things like key presses, or mouse moving. Hardware interrupts are asynchronous and can occur in the middle of an execution.

  Software interrupt- Either exceptional conditions (like diving by 0) or a special instruction which causes an interrupt when it is executed (some condition is met and the process ends).

  A common form of multitasking is time-sharing which is rapid context switches making it seem like multiple processes are being executed at the same time on the processor. 
  The OS holds the information about the active processes in process control blocks*. The resources are usually associated with threads*.

  Process Control Block is a data structure in the operating system which holds information needed to manage a particular process.

  Thread the smallest sequence of programmed instructions that be managed independently by a scheduler. In most cases threads are part of processes.

  Threads generally share process state, memory, and other resources. Context switching is faster between threads rather than processes.

  Single threading is when you process one command at a time. Multithreading means threads share resources within the context of a process.

  Multithreads are more responsive, since separate threads can handle different execution tasks, faster execution, since threads can use parallel execution, better system utilization, since one thread can access the cache while another accesses external storage.  
  Some of the drawbacks are synchronization, programmers must remember that the address space is shared between threads and ensure there is not a race condition. Additionally, threads can perform an illegal operation which may crash the system and disrupt the processing.

  Threads are typically subsets of a process, carry less state information, share memory and other resources, share address spaces, and have faster context switching over processes.

  Processes have individual address spaces, carry more state information, only communicate through inter-process communication mechanisms*

  An address space is range of addresses which may correspond to memory cell, or other logical or physical entity.

  A processor can only process one task at a time, unless it has multiple cores. In that case you can handle multithreading.</p>
  <p>What is a sempahore?

  A semaphore is an ADT (abstract data type) used to control access to a common resource by multiple processes in a concurrent system. A trivial semaphore is a variable which has a changed value, which allows or disallows access to that resource.

  They are useful in preventing race conditions. Sempahores can be counting (i.e. there is a certain amount of a resource allowed, and the semaphore tracks how much is being used) and binary (1 and 0, used or unused, locked or unlocked).

  Programmers must be careful of requesting a resource, but forgetting to release it, releasing a resource that was not requested, holding a resource for a long time without using it, using a resource without requesting it (or after releasing it).


  Translation Lookaside buffer

  TLB is a memory cache that is used to reduce the time taken to access a user memory location. If a user is looking for something, then the TLB will be faster at finding it.

  When an address space switch happens, the TLB may hold information that is irrelevant, so the computer may flush the TLB, meaning it will be empty. This operation is not the most efficient, so newer CPUS mark which process an entry is for.



  What is concurrency?

  Concurrency is the property of a program being able to be broken up into separate partially ordered units. Meaning, even if portions of a program are executed out of order, the result will be the same.


  What is a monitor?

  A monitor consists of a mutex (lock) and condition variables. Condition variables are a container of threads that are waiting for a certain condition. Monitors provide a mechanism for threads to give up exclusive access in order to wait for some condition to be met.


  What is system design?
  A system is the creation, defining, and development of systems in order to satisfy user requirements. Software is standardized which means systems can now be modular, and this increases the importance of software engineering.

  Unified Modeling Language is the standard language which is supposed to provide a way to visualize the design of a system. The idea of UML is to blueprint elements such as activities (jobs), components of the system (how they interact with software components), how the system will run, how components and interfaces interact, and external user interface.

  UML have static (structural) views which emphasize the static structure of the system using objects, attributers, operations, and relationships. Including class diagrams and composite structure diagrams.

  Used to document the software architecture of software systems, for example the component diagram describes how a software system is split up into components and shows the dependencies amongst these components.

  It also has dynamic (behavioral) view which emphasizes the dynamic behavior of the system through displaying the internal states of objects.

  Used to describe how software/ideas are supposed to function and interact with each other.

  Logical design pertains to the abstract idea of how the data flows, inputs/outputs to the system, etc.   The physical design describes how data is actually input into the system, and is usually broken down into user interface, data design, and process design.   User interface design is concerned with how users add information to the system, and how it presents that information back to them.

  Data design is concerned with how the data is represented and stored within the system.

  Process design is concerned with how data moves through the system, how/where it is validated, etc.


  What is an interface?

  Interfaces are places where two components of technology communicate with non related components. A hardware interface is usually defined by the mechanical, electrical, and logical signals.

  Software interfaces are more general, and encompass more parts. A software interface could refer to an operating system, which interfaces with the hardware. Applications and programs can interface with streams*. Object oriented programs interacts with methods.

  A stream is a sequence of data elements made available over time.

  Software interfaces should be designed such that access is not public automatically, access should be defined through access points.

  Distributed computing

  Components located on connected (networked) computers communicate and coordinate their actions by passing messages. These components interact to achieve a common goal. Significant characteristics include concurrency of components, lack of a global clock, and independent failure of components.

  Distributed program is a distributed system that is run by a computer program. In distributed programming it is common for tasks to be partitioned out  and solved by one, or more, computers.

  Distributed used to mean computers that were spread out in a geographic area, but today can mean autonomous processes that run on the same computer, and interact with each other by message passing.

  Concurrent computing, parallel computing and distributed computing have a lot of overlap and no clear distinction. A system could be described as parallel and distributed. Distributed computing is a loosely coupled form of parallel computing (parallel computing- tight coupling of distributed).

  Parallel computing- all processors have access to a shared memory to exchange information.

  Distributed computing- each processor has its own private memory, information is exchanged by passing messages between processors.

  Architectures- still distributed computing
  Low level- CPUs are connected via some sort of network, be it printed onto a circuit board or made up of loosely coupled devices.

  Higher level- A communication system must interconnect these processes running on those CPUs.

  Distributed programming falls into some of these categories:

  Client-server- clients contact the server for data then format and display int to the users. Permanent changes are committed back to the server.

  In this model work is done by a server, and is requested by a client. The server does the work and the client initiates the contact. Examples email, network printing, the world wide web.

  Three-tier- Most web applications. Architectures that move the client intelligence to a middle client. Simplifies application deployment.

  N-tier- refer to web applications which further forward their requests to enterprise services. This lead to the success of application servers.

  multi-tier architecture - client server architecture presentation, application processing, and data management functions are physically separated. Three tier is the most common.

  Example- web development such as e-commerce website. A front end web server which delivers content. A middle content processing and generation level application server (Rails, Django, Flask). Then a backend database or data store, made up of data sets and database management systems software, which provides access to the data.

  Peer to Peer- no special machines that provide a service or manage the network resources. Everyone is considered equal in doing the task. Uses include file sharing, instant and voice communication.

  Example-  Skype, Napster

  Distributed systems are more reliable. Many low end computers provide a lower chance of failure than one high end computer.


  Scaling out vs scaling up

  Multi-core concurrency is referred to as Scale up, and distributed computing is referred to as scale out.

  Scaling up is the process of making a computer more and more workload, while scaling out is getting more computers to handle the problem.   Scaling up is cheaper, but is more risky.


  SQL, NoSQL, and serverless:
  Sql is a relational database


  What is MVC?

  Model, view, controller. The model level is the one which holds the data. A controller sends commands to the model, or to the view to change the presentation of the model/data. The view is any output representation of information, i.e. char or diagram.

  A Star?

  An informed search algorithm for path-finding. It uses the advantages of Dijkstra’s (finding the shortest path) and Best First Search. It does this by using a guide to determine the best next point (based on the current/starting point) and the next best point (based on the goal end point).
</p>
<p>
  enterprise service bus - implements a communication system between interacting software applications in service-oriented architecture (SOA). It promotes agility and flexibility with regard to high protocol-level communication between applications.

  micro services are a software architecture style where applications are composed of small, independent processes communicating with language-agnostic APIs. They are highly decoupled, and focus on doing a small task.

  micro services are not always scalable, because the centralized services and databases must also be scalable. They also put pressure on APIs.

  Because micro services are built on the cloud and have virtualization, servers can be created and provision when the demand arises.

  Scalability as a cube, with an X, Y, and Z axis. Scaling by running multiple copies of an application load-balanced across servers is the X-axis, scale by cloning. Each copy could need all of the data, requiring more memory to be effective. It does not tackle the problems of increasing application complexity.

  Micro services generally fall on the Y axis, which focuses on breaking the applications into components and services. Also known as scale by splitting up. Each service has one ore more closely related functions. This can be doing by breaking services up with verbs, implementing a single  use case such as checkout. Another option is to decompose the application by noun and create services responsible for all operations related to entities, such as customer management. Applications can also use verb and noun based decomposition.


  The Z-axis, known as scale by splitting similar things, is running identical copies of code across multiple servers, except that servers are only responsibly for a subset of the application, rather than the entire thing.

  Benefits - each server only deals with a subset of data
  - improves cache utilization and reduces memory usage and I/O traffic
  - Improves transaction scalability since requests are typically distributed across multiple servers
  - Improves fault isolation, since failure only makes part of the data inaccessible.
  Drawbacks - Increased complexity
  - Requires a partitioning scheme, can be tricky for repartitioning data


  Because micro services can be on multiple servers, when demand increases, you have to make sure all portions scale appropriately.

  Using the Z-axis allows you to send people who are premium to better servers, or based on primary key data being accessed.

  The advantages are that in the old system, the whole application had to be scaled accordingly. But now, with micro services, you can scale up only the portion of the app which is in high demand.

  (application deliver controller)

  Sharding- A horizontal partition of data in a database or search engine. Shards are held on different database server instances, to spread load. Some portions of data may appear in all shards, while others only appear in a single shard. Each shard/server acts as a single source for a subset of data.

  Shards have fewer total rows in each table in each database. But why?

  Shards can be placed on separate hardware, with allows the distribution of data over a number of machines, enabling improved performance.

  Drawbacks are heavier reliance on the connection between servers, increased latency (especially when you have to query multiple shards), data is usually indexed one way, making certain searches sub-optimal, and there can be issues of consistency and durability due to more complex failure modes of a set of servers.

  Database Normalization (normalization)- the process of organizing columns(attributes) and tables (relations) of a relational database to reduce data redundancy and improve data integrity. It can also refer to simplifying the design of a database so it achieves the optimum structure. Removing redundancies from the database by splitting tables and linking them with keys.

  Vertical partitioning- creating tables with fewer columns and using additional tables to store the remaining columns. Good to use when you want to split dynamic (slow) data from static (fast) data.

  Vertical/horizontal data partitioning refers to physical optimization, normalization is a conceptual optimization.


  N-tier data applications-

  Presentation Tier- users interact with an application. Typically, this tier does not access the data tier, it communicate with the data tier by the data access component in the middle tier.

  Middle tier- The layer of the presentation tier and data tier use to communicate, generally includes business rules, data validation, and other such things.

  Data tier- Servers/ storage of application’s data.

  Applications which are in different tiers. Also known as distributed applications or multitier applications.
</p>

  </div>
</div>
</body>
