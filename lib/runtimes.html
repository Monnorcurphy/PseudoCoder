

<div>
  <h1>Big O</h1>
  <h2>What is Big O</h2>
  <h2>Important terminology</h2>
  <h2>Different run times</h2>
  <h2>NP Complete</h2>

Big O Notation

You might be here because you are trying to become a programmer, trying to improve yourself as a programmer, or you have a programming interview tomorrow and you are totally screwed.  Regardless of any of this, you can see the common theme in the stories above. That is, you are a piece of trash. Seriously. Think about what you have done for a second.

Thankfully, I am here to set you down the right road. I will take accolades, money, or job offers. I know, I know, I am too good to you. What can I say, I am a giver.  The first thing you should know before you know how to program a line of code should be the things on this page. It will come with a grain of pepper. That grain is, you should not try to optimize too early. You are going to write inefficient programs, likely for the rest of your short career. But, if you try to make something perfect before you write it, you are never going to build anything, or anything worth while.

Intro example

I am a big fan of analogies because they make it easy for smart people to explain complex things to….well, people like you! You are so smart, who’s a little smarty? It’s you! It’s you!

Alright, let’s say you have to solve a problem, like washing the dishes, and you have 3 workers. Each worker will be so efficient at a task, I won’t get too mired down with the details since it would be too confusing for your tiny…uh, never mind.

When you assign these workers, there is a best way, an average way, and a worst way. And you cannot always control how that turns out. Like worker one’s sippie cup might have spilled, and now he won’t agree to dry the dishes. You can try to force him, but he unionize with the other works, or worse….tell his mother. *Shudder*  So you have to deal with that and assign him to a different task. This situation is exactly like Big O, Theta, and Omega. It is a way to tell people, in the best conditions this is how efficiently I am solving this problem, in the average case, this is how efficient, and in the worst case this is the case. So which is which?

Big O- The workers revolt

Big O is the worst case scenario, all of your most efficient workers have decided that they will not do the job that is best suited to them. Instead, they want to do the job they are the worst at. It’s like a clown trying to be funny, or my wife trying to love me, just not a good fit.

How does this apply to the real world? And by real world I mean digital world of computer programming. Let’s say you have to sort a list of items. In the worst case, the items would be sorted, but in reverse order. The exact WORST possible situation. So, that is where Big O lives. Big O says, everything has gone wrong. Everything is terrible. No one wants this, but we still have to solve this problem. How efficient are you now. The lower your Big O, the more impressive it is.


Big Omega- The workers are happy

Big Omega is the case where all workers are happy, and they do the perfect job for them. Instead of everything going wrong, everything is going perfectly, and nothing bad can touch you here. It’s a lot like kids in college,  idealistic and perfect.  This is if you have to sort a list, and it is already sorted. HOORAY! On the flip side, the worse your Big Omega is, the more unimpressive it is.

Time to pause to experience the irony. Big O is all about the worst possible case, everything is terrible, and yet it is the best place to impress someone. While Big Omega is all about the best case, everything is great, and it is the easiest way to show someone you are a big moron. Just something interesting to ponder, if you don’t see the irony, don’t worry. It’s because your big brain is too big to comprehend it. Who’s a good reader? It’s still you! It’s still you!

Big Theta- The workers have unionized

Let’s say that you have your three workers, and they decide that they always want to accomplish the task in the relative amount of time. They always want to finish the job in an hour. So, even if Brian spills his sippie cup, or Joan falls down the stairs, again, they will guarantee that the job will always be finished in an hour. This could look different and happen in many ways, but it’s not important. The concept is the important part.

If you can solve a problem and your Big O and Big Omega are the same, then you have a Big Theta. Not all problems have a Big Theta, since sometimes in the best case you will be able to solve a problem quickly, while the worst case will take much longer.  These concepts are basic, but they are important for you to move forward. In life no one cares about the best case, because we aren’t college kids. We live in the real world. And if you can solve problems under the worst conditions, then we know how much you are worth.

Factorial- Batten down the hatches
The notation O(n!)

What it means- This is literally the worst time you can get.

An example, and where you will see it:
 If you were a panhandler and needed to get money from as many people as possible, but you did not want to waste your time. Let’s say you are low on food, and you need to use every calorie as efficiently as possible. So, you are going to 3 houses, how do you find the most efficient route.  You calculate the distance from house 1 to 2, then 2 to 3. THEN you calculate the distance from house 2 to 1, then 1 to 3. Then you calculate the distance from 2 to 3, then 3 to 1. And so on. This is a version of the Traveling Salesman problem. It is part of a special series of problems, which we will touch on later. 
If you need to calculate “all possible” or “everything”…pretty much if someone is like “Hey, there’s a ton of stuff in this thing we got, and we need to know what the best way to get through all of it, including between them.” It is probably in this class of problems. Specifically, if someone asks for all permutations, it’s Factorial.


Exponential- Sell the house, invest in seeds

The notation O(2 ^N)

What it means- You are solving a bad problem, but hey, at least it’s not factorial.

An example and where you will see it:

The above example is still a good way to demonstrate this class. Let’s say that you figure out there are certain routes which are efficient, and there is no way to beat them. Like if the house 1 and house 2 were right next to each other, so regardless of all other situations, you should travel to those houses one after another (be it 1 then 2, or 2 then 1). In this instance, you don’t need to compute every iteration. You will often see these types of solutions used in dynamic programming to solve factorial problems.

Polynomial- Buy a bunker, and start filling it with canned peaches

The notation O(N^2)

What it means- This problem sucks, a lot, and it is going to be expensive to solve this problem

An example and where you will see it:

When you multiply two numbers, like 37 * 48, you probably do it this way. 8 * 7, 8* 3, 4* 7, 4 * 3. That is a perfect example, for every number in 37, you are doing some work on it with every number in 48. If you had to go through two things and you needed to use stuff from both source 1 and source 2, then you are likely dealing with N squared. Generally, you will see this when you first start solving problems. They can usually be improved upon, since they are brute force solutions, that is not always true however.

Linearithmic - Buy health insurance, soonish
The notation O(n log n)

What it means-

An example and where you will see it:




O(1)
O(Log N)
O(N)



</div>
